(** Various operations for the vector space [int -> QQ] *)

open Syntax

(** Raised for unsolvable systems of linear equations *)
exception No_solution

exception Nonlinear

(** Sparse vector with integer entries. *)
module ZZVector : sig
  include Ring.Vector with type dim = int and type scalar = ZZ.t
  val compare : t -> t -> int
  val pp : Format.formatter -> t -> unit
  val pp_term : (Format.formatter -> int -> unit) -> Format.formatter -> t -> unit
  val show : t -> string
  val hash : t -> int
end

(** Sparse vector with rational entries. *)
module QQVector : sig
  include Ring.Vector with type dim = int and type scalar = QQ.t
  val compare : t -> t -> int
  val pp : Format.formatter -> t -> unit
  val pp_term : (Format.formatter -> int -> unit) -> Format.formatter -> t -> unit
  val show : t -> string
  val hash : t -> int
  val slice : int -> int -> t -> t
  val split_leading : t -> (dim * scalar * t) option

  (** Are all entries integers? *)
  val is_integral : t -> bool

  (** Find common denominator of all entries.  Multiplying by the cmmon
     denominator yields an integral vector. *)
  val common_denominator : t -> ZZ.t

  (** Greatest common divisor of all entries. *)
  val gcd_entries : t -> QQ.t
end

(** Sparse matrix with rational entries. *)
module QQMatrix : sig
  include Ring.Matrix with type scalar = QQ.t
                       and type vector = QQVector.t

  val pp : Format.formatter -> t -> unit
  val show : t -> string

  (** Matrix exponentiation by a positive integer power. *)
  val exp : t -> int -> t

  (** Compute a list rational eigenvalues of the square sub-matrix
     over the given dimensions, along with their algebraic
     multiplicities. *)
  val rational_eigenvalues : t -> int list -> (QQ.t * int) list

  (** [col_slice i j m] returns the sliced matrix m[i:j] omitting all columns before the ith
      and omitting the jth column and all columns after. *)
  val col_slice : int -> int -> t -> t
end

(** [nullspace mat dimensions] computes a basis for the vector space [{ x :
    mat*x = 0}], projected on to the set of dimensions [dimensions].  (Note
    that the nullspace is not finitely generated in [int -> QQ], hence the
    projection). *)
val nullspace : QQMatrix.t -> int list -> QQVector.t list

(** [solve_exn mat b] computes a rational vector [x] such that [mat*x =
    b]. Raises [No_solution] if there is no solution. *)
val solve_exn : QQMatrix.t -> QQVector.t -> QQVector.t

(** [solve mat b] computes a rational vector [x] such that [mat*x = b], if
    such a vector exists.  Otherwise, return [None]. *)
val solve : QQMatrix.t -> QQVector.t -> QQVector.t option

(** [vector_right_mul m v] computes [m*v] *)
val vector_right_mul : QQMatrix.t -> QQVector.t -> QQVector.t

(** [vector_left_mul v m] computes [(v^t)*m] *)
val vector_left_mul : QQVector.t -> QQMatrix.t -> QQVector.t

(** Given two matrices [A] and [B], compute matrices [C] and [D] such
   that [CA = DB], and for any [E] and [F] such that [EA = FB], there
   exists a (unique) [U] such that [UCA = EA (= UDB = FB)] *)
val pushout : QQMatrix.t -> QQMatrix.t -> (QQMatrix.t * QQMatrix.t)

(** Given two matrices A and B, compute a matrix C such that CB = A (if one
    exists).  C exists when the rowspace of B is contained in the rowspace of
    A.  If A and B are invertible, then C is exactly AB{^-1}. *)
val divide_right : QQMatrix.t -> QQMatrix.t -> QQMatrix.t option

(** Given two matrices A and B, compute a matrix C such that BC = A (if one
    exists).  C exists when the columnspace of B is contained in the columnspace of
    A.  If A and B are invertible, then C is exactly B{^-1}A. *)
val divide_left : QQMatrix.t -> QQMatrix.t -> QQMatrix.t option

(** Compute a list of (rational eigenvalue, generalized eigenvector)
   pairs of a finite dimensional square submatrix of a given
   matrix. The submatrix is determined by the list of dimensions given
   as the second parameter. *)
val rational_spectral_decomposition : QQMatrix.t -> int list -> (QQ.t * QQVector.t) list

(** Compute a list of (period, rational eigenvalue, generalized
   eigenvector) triples of a finite dimensional square submatrix of a
   given matrix. The submatrix is determined by the list of dimensions
   given as the second parameter. *)
val periodic_rational_spectral_decomposition : QQMatrix.t ->
  int list ->
  (int * QQ.t * QQVector.t) list

(** [jordan_chain mA lambda v] computes the (left) Jordan chain generated by
   [v] corresponding to the eigenvalue [lambda] of [mA].  This is a
   list of vectors v{_ 0},...,v{_ n} such that
   {ul {- v{_ 0} = v }
       {- for each i < n we have v{_ i}(mA-lambda*I) = v{_ {i+1}} }
       {- v{_ n}(mA-lambda*I) = 0 } }
 *)
val jordan_chain : QQMatrix.t -> QQ.t -> QQVector.t -> QQVector.t list

(** {2 Rational vector spaces} *)
module QQVectorSpace : sig
  (** Vector spaces are represented by a list of basis vectors *)
  type t = QQVector.t list

  val pp : Format.formatter -> t -> unit

  val equal : t -> t -> bool

  (** [subspace a b] checks whether [a] is a subspace of [b] *)
  val subspace : t -> t -> bool

  (** Empty vector space *)
  val empty : t

  (** Check whether a given vector space is empty. *)
  val is_empty : t -> bool

  (** Create a matrix whose rows form a basis for the space *)
  val matrix_of : t -> QQMatrix.t

  (** Given a matrix *with linearly independent rows*, get basis for its rowspace *)
  val of_matrix : QQMatrix.t -> t

  (** Given a vector space V and a vector v, does v belong to V *)
  val mem : t -> QQVector.t -> bool

  (** Intersect two vector spaces *)
  val intersect : t -> t -> t

  (** Given vector spaces U and V, compute a basis for the direct sum
      [{ u+v : u in U, v in V }] *)
  val sum : t -> t -> t

  (** Given vector spaces U and V, compute a basis for a vector space W such that
      [sum (diff U V) W = U].  NOTE: this vector space is not unique. *)
  val diff : t -> t -> t

  (** [standard_basis n] returns standard basis for n-dimensional space *)
  val standard_basis : int -> t

  (** Compute a basis for the vector space spanned by a given set of vectors *)
  val basis : QQVector.t list -> t

  (** Simplify a basis using Gauss-Jordan elimination *)
  val simplify : t -> t

  (** Scale a basis to have all integer coordinates. *)
  val scale_integer : t -> t

  (** Find the dimension of the given vector space *)
  val dimension : t -> int
end

(** {2 Rewriting} *)

module type SparseArray = sig
  type scalar
  type dim
  type t
  val zero : t
  val split_leading : t -> (dim * scalar * t) option
  val add : t -> t -> t
  val add_term : scalar -> dim -> t -> t
  val scalar_mul : scalar -> t -> t
  val fold : (dim -> scalar -> 'a -> 'a) -> t -> 'a -> 'a
  val pp : Format.formatter -> t -> unit
end

module type LinearSpace = sig
  type t
  type scalar
  type vector

  (** Logical equality *)
  val equal : t -> t -> bool

  (** [subspace a b] checks whether [a] is a subspace of [b] *)
  val subspace : t -> t -> bool

  (** Linear space containing only zero *)
  val zero : t

  (** Check whether a given space is {0}. *)
  val is_zero : t -> bool

  (** Check membership of vector within a linear space *)
  val mem : t -> vector -> bool

  (** Intersect two spaces *)
  val intersect : t -> t -> t

  (** Given spaces U and V, compute a basis for the direct sum
      [{ u+v : u in U, v in V }] *)
  val sum : t -> t -> t

  (** Given spaces U and V, compute a basis for a space W such that
      [sum (diff U V) W = U].  NOTE: this vector space is not unique. *)
  val diff : t -> t -> t

  (** Retrieve an ordered basis for a space *)
  val basis : t -> vector BatEnum.t

  (** Find the dimension of the given space *)
  val dimension : t -> int

  (** [add v U] computes the space [{ av + u : a in K, u in U }] *)
  val add : vector -> t -> t

  (** [reduce v S] compute a representative of v in the quotient space
     [V/S]. *)
  val reduce : t -> vector -> vector

  (** Smallest vector space that contains all vectors in the given
     enumeration. *)
  val span : vector BatEnum.t -> t
end

(** Finite-dimensional (sub)spaces of sparse arays *)
module MakeLinearSpace
    (K : Algebra.Field)
    (D : Map.OrderedType)
    (V : SparseArray with type dim = D.t
                      and type scalar = K.t) :
  LinearSpace with type scalar = K.t
               and type vector = V.t

(** {2 Linear maps} *)

(** Linear maps from a subspace of S into T. *)
module MakeLinearMap
    (K : Algebra.Field)
    (D : Map.OrderedType)
    (S : SparseArray with type dim = D.t
                      and type scalar = K.t)
    (T : sig
       type scalar = K.t
       type t
       val zero : t
       val is_zero : t -> bool
       val add : t -> t -> t
       val scalar_mul : scalar -> t -> t
       val pp : Format.formatter -> t -> unit
     end) : sig
  type t

  (** The map from the zero space to T *)
  val empty : t

  (** [apply f x] applies [f] to [x] if [x] belongs to [f]'s domain,
     otherwise gives [None] *)
  val apply : t -> S.t -> T.t option

  (** [add x y f] extends [f] with the binding [x -> y], provided that [f x]
     is either undefined or equal to [y], otherwise gives [None]. *)
  val add : S.t -> T.t -> t -> t option

  (** [add x y f] extends [f] with the binding [x -> y], provided [x] is not
      already in the domain of [f], otherwise raises [Invalid_argument]. *)
  val add_exn : S.t -> T.t -> t -> t

  (** [may_add x y f] extends [f] with the binding [x -> y], provided [x] is
     not already in the domain of [f], otherwise gives [f]. *)
  val may_add : S.t -> T.t -> t -> t

  (** Retrieve an enumeration of bindings that defines the linear map *)
  val enum : t -> (S.t * T.t) BatEnum.t

  (** As [enum], but with the order reversed. *)
  val reverse : t -> (S.t * T.t) BatEnum.t

  (** Compose a map with a linear map on the target space.  The function must
     be linear for the composition to be well-defined. *)
  val compose : t -> (T.t -> T.t) -> t
end

exception Not_in_context

(** Translate between sparse arrays (of arbitrary dimension type) and rational
   vectors (with dimensions drawn from an initial segment of the naturals) *)
module type DenseConversion = sig
  type context
  type dim
  type vec
  (** [make-context [d0, ..., dn]] creates a conversion context that
     associates each [di] with the integer [i].  [Invalid_arg] is raised if a
     dimension appears more than once in the input list. *)
  val make_context : dim list -> context

  (** [min_context xs] creates a minimal conversion context in which each
     dimension in each vector in [xs] appears. *)
  val min_context : vec BatEnum.t -> context

  (** Number of dimensions of the conversion context *)
  val dim : context -> int

  (** Translate an integer to a dimension.  Raises [Not_in_context] if the
     integer is not within bounds.  *)
  val dim_of_int : context -> int -> dim

  (** Translate a dimension to an integer.  Raises [Not_in_context] if the
     dimension does not appear in the context.  *)
  val int_of_dim : context -> dim -> int

  (** Convert a sparse array to a vector.  Raises [Not_in_context] if
     conversion context does not contain all required dimensions. *)
  val densify : context -> vec -> QQVector.t

  (** Convert a vector to a sparse array.  Raises [Not_in_context] if the
     integral dimensions are outside the bounds of the conversion context. *)
  val sparsify : context -> QQVector.t -> vec

  (** Does a dimension belong to a conversion context? *)
  val mem : context -> dim -> bool

  (** Pretty-print association between integers and dimensions. *)
  val pp : (Format.formatter -> dim -> unit) -> Format.formatter -> context -> unit
end

module MakeDenseConversion
    (D : Map.OrderedType)
    (S : SparseArray with type dim = D.t
                      and type scalar = QQ.t)
  : DenseConversion with type dim = D.t
                     and type vec = S.t

(** {2 Affine terms} *)

(** Various operations for manipulating affine terms over symbols, represented
    as rational vectors *)

(** Map a symbol to a dimension.  The following equations hold:
    - [sym_of_dim (dim_of_sym sym) = Some sym]
    - [sym_of_dim const_dim = None] *)
val sym_of_dim : int -> symbol option

(** Map a dimension to symbol.  The following equations hold:
    - [sym_of_dim (dim_of_sym sym) = Some sym]
    - [sym_of_dim const_dim = None] *)
val dim_of_sym : symbol -> int

(** Dimension for representing the coefficient of the constant 1. *)
val const_dim : int

(** Representation of a rational number as an affine term.  The equation
    [const_of_linterm (const_linterm qq) = Some qq] must hold. *)
val const_linterm : QQ.t -> QQVector.t

(** Convert an affine term to a rational number, if possible.  The equation
    [const_of_linterm (const_linterm qq) = Some qq] must hold. *)
val const_of_linterm : QQVector.t -> QQ.t option

(** Convert a rational vector representing an affine term.  Raises [Nonlinear]
    if the input term is non-linear. *)
val linterm_of : 'a context -> 'a arith_term -> QQVector.t

(** Convert a rational vector to an affine term.  The equation [of_linterm srk
    (linterm_of srk t) = t] must hold. *)
val of_linterm : 'a context -> QQVector.t -> 'a arith_term

(** Pretty-print an affine term *)
val pp_linterm : 'a context -> Format.formatter -> QQVector.t -> unit

(** [evaluate_linterm env t] evaluates the affine term t in the environment
    [env] *)
val evaluate_linterm : (symbol -> QQ.t) -> QQVector.t -> QQ.t

(** Count the number of dimensions with non-zero coefficients *)
val linterm_size : QQVector.t -> int

(** [term_of_vec srk t vec] creates a term representation of [vec] by
   interpreting each dimension i as the term [t i]. *)
val term_of_vec : ('a context) -> (int -> 'a arith_term) -> QQVector.t -> 'a arith_term

(** Evaluate a vector by interpreting each coordinate according to the
   given interpretation (the interpretation of [const_dim] is fixed to
   be 1).  *)
val evaluate_affine : (int -> QQ.t) -> QQVector.t -> QQ.t
